// Built-in functions
function abs(n: s64): s64 {
   if (n > 0) n else n * -1
}

// Constant Functions
function corner_snapping_threshold(): s64 {
    20
}

function snapping_threshold(): s64 {
    20
}

// Built-in Object ID type
typedef OID = s64


////////// Sort Hiearchy ///////////////////
// Sort Literals
typedef Axes = X | Y
typedef Directions = DLeft | DRight | DTop | DBottom
// Nodes of the hierarchy
typedef Node = string

// Sorts and attributes
input relation Object(oid: OID, sort: Node)
typedef AttributeValue = Width(width: s64)
    | Height(height: s64)
    | Target(target: OID)
    | Distance(distance: s64)
    | Direction()

input relation Attribute(oid: OID, )

relation Width(oid: OID, val: s64)
relation Height(oid: OID, val: s64)
relation Target(oid: OID, val: OID)
relation Distance(oid: OID, val: s64)
relation Direction(oid: OID, val: string)

input relation Fluent(id: s64, type: string, value: string)
relation Coordinate()
Coordinate() :- Fluent()

output relation Output_Fluent(id: s64, type:string, value: string)

// Encode Hiearchy facts
output relation Link(_1: Node, _2: Node)
Link("Actions", "Universe").
Link("Window_Action", "Actions").
Link("Open_Window", "Window_Action").
Link("Drag", "Window_Action").
Link("Rectangles", "Universe").
Link("Monitors", "Rectangles").
Link("Windows", "Rectangles").

output relation Is_A(_1: OID, _2: Node)
Is_A(obj, sort) :- Object(obj, sort).

output relation Instance(_1: OID, _2: Node)
Instance(obj, sort) :- Is_A(obj, node).
Instance(obj, sort1) :- Instance(obj, sort2), Link(sort1, sort2).

// Statics
output relation Opposite_Direction(_1: string, ret: string)
output relation Opposite_Axis(_1: string, ret: string)
output relation Axis(_1: string, ret: string)
output relation Direction_Factor(_1: string, ret: s64)

/////// Fluents //////////////////
// Basic
input relation Input_Coordinate(_1: OID, _2: string, ret: s64)
output relation Coordinate(_1: OID, _2: string, ret: s64)
Coordinate(x1, x2, x3) :- Input_Coordinate(x1, x2, x3).

// Defined
output relation Side(_1: OID, _2: string, _3: s64)
output relation On_Same_Line(_1: OID, _2: OID, _3: string)
output relation Overlaps(_1: OID, _2: OID)
output relation Attracts(_1: OID, _2: OID, _3: string)
output relation Not_Final_Coordinate(_1: OID, _2: string, _3: s64)
output relation Final_Coordinate(_1: OID, _2: string, _3: s64)
output relation Not_Snapped(_1: OID, _2: OID)
output relation Snapped(_1: OID, _2: OID)
output relation Snapped_To_Corner(_1: OID, _2: OID)
output relation Moving(_1: OID)
output relation Stationary(_1: OID)
output relation Predistance(_1: OID, _2: OID, _3: s64)
output relation Not_Distance(_1: OID, _2: OID, _3: s64)
output relation Distance(_1: OID, _2: OID, _3: s64)
output relation Not_Closest(_1: OID, _2: OID)
output relation Closest(_1: OID, _2: OID)
output relation Nearest_Side(_1: OID, _2: OID, _3: string)
output relation Nearest_Corner(_1: OID, _2: OID, _3: string, _4: string)

// Causal Law Outputs
output relation Output_Coordinate(_1: OID, _2: string, ret: s64)

output relation Output_Moving(_1: OID)
input relation Input_Moving(_1: OID)
Moving(x1) :-Input_Moving(x1).

///////////// Axioms ///////////////
Opposite_Direction(Left, Right).
Opposite_Direction(Top, Bottom).
Opposite_Direction(a, b) :-
    Opposite_Direction(b, a).
Opposite_Axis(X, Y).
Opposite_Axis(Y, X).
Axis(Left, X).
Axis(Top, Y).
Axis(dir, a) :-
    Axis(dir__prime, a),
    Opposite_Direction(dir, dir__prime).

Direction_Factor(Right, 1).
Direction_Factor(Bottom, 1).
Direction_Factor(Left, -1).
Direction_Factor(Top, -1).

Side(rectangle, Left, value) :-
    Coordinate(rectangle, X, value).
Side(rectangle, Top, value) :-
    Coordinate(rectangle, X, value).

Side(rectangle, Right, r_value) :-
    Side(rectangle, Left, l_value),
    Universe(.oid = rectangle, .child = E_Rectangles {
        .rectangles = Rectangles {
            .width = w
        }
    }),
    var r_value = l_value + w.

Side(rectangle, Bottom, b_value) :-
    Side(rectangle, Left, t_value),
    Universe(.oid = rectangle, .child = E_Rectangles {
        .rectangles = Rectangles {
            .height = h
        }
    }),
    var b_value = t_value + h.

On_Same_Line(a, b, axis) :-
    Side(a, dir, a1),
    Axis(dir, axis),
    Opposite_Direction(dir, dir__prime),
    Side(a, dir__prime, a2),
    Side(b, dir, b1),
    Side(b, dir__prime, b2),
    a != b,
    a1 < b2,
    a2 > b1.

Overlaps(a, b) :-
    On_Same_Line(a, b, X),
    On_Same_Line(a, b, Y).

Predistance(a, b, b) :-
    Instance(a, "Windows"),
    Instance(b, "Windows"),
    On_Same_Line(a, b, axis),
    Axis(dir, axis),
    not Overlaps(a, b),
    Side(a, dir, e1),
    Side(b, dir__prime, e2),
    Opposite_Direction(dir, dir__prime),
    var d = abs(e1 - e2).

Predistance(a, b, d) :-
    Instance(a, "Windows"),
    Instance(b, "Monitors"),
    Side(a, dir, e1),
    Side(b, dir, e2),
    var d = abs(e1 - e2).

Predistance(a, b, d) :-
    Predistance(b, a, d).

Not_Distance(a, b, d) :-
    Predistance(a, b, d),
    Predistance(a, b, d__prime),
    d__prime < d.

Distance(a, b, d) :-
    Predistance(a, b, d),
    not Not_Distance(a, b, d).

Nearest_Corner(a, b, dir, dir__prime) :-
    Nearest_Side(a, b, dir),
    Axis(dir, ax),
    Opposite_Axis(ax, ax__prime),
    Axis(dir__prime, ax__prime),
    Opposite_Direction(dir__prime, dir__prime__prime),
    Side(a, dir__prime, a1),
    Side(a, dir__prime, b1),
    Side(a, dir__prime__prime, a2),
    Side(b, dir__prime__prime, b2),
    abs(a1 - b1)  <  abs(2 - b2).

Nearest_Corner(a, b, dir, dir__prime) :-
    Nearest_Corner(a, b, dir__prime, dir).

Not_Closest(a, b) :- 
    Distance(a, b, d),
    Distance(a, c, d__prime),
    d__prime < d.

Closest(a, b) :-
    Instance(a, "Windows"),
    Instance(b, "Rectangles"),
    not Not_Closest(a, b).

Output_Coordinate(a, X, 0) :-
    Instance(action, "Open_Window"),
    Universe(
        .oid = action,
        .child = E_Actions {
            .actions = Actions {
                .child = E_Window_Action {
                    .window_action = Window_Action {
                        .target = a
                    }
                }
            }
        }
    ).
    
    
Output_Coordinate(a, Y, 0) :-
    Instance(action, "Open_Window"),
    Universe(
        .oid = action,
        .child = E_Actions {
            .actions = Actions {
                .child = E_Window_Action {
                    .window_action = Window_Action {
                        .target = a
                    }
                }
            }
        }
    ).

Nearest_Side(a, b, dir) :-
    Instance(a, "Windows"),
    Instance(b, "Windows"),
    Side(a, dir, edge_a),
    Opposite_Direction(dir, dir__prime),
    Side(b, dir__prime, edge_b),
    Distance(a, b, d),
    edge_a - edge_b == d.

Nearest_Side(w, m, dir) :-
    Instance(w, "Windows"),
    Instance(m, "Monitors"),
    Side(w, dir, edge_w),
    Side(m, dir, edge_m),
    Distance(w, m, d),
    var d__prime = edge_w - edge_m,
    d == d__prime.

Nearest_Side(a, b, dir) :-
    Opposite_Direction(dir, dir__prime),
    Nearest_Side(b, a, dir__prime).

Output_Coordinate(window, axis, new_coord) :-
    Instance(action, "Drag"),
    Universe(
        .oid = action,
        .child = E_Actions {
            .actions = Actions {
                .child = E_Window_Action {
                    .window_action = Window_Action {
                        .target = a,
                        .child = E_Drag {
                            .drag = Drag {
                                .distance = d,
                                .direction = dir
                            }
                        }
                    }
                }
            }
        }
    ),
    Axis(dir, axis),
    Direction_Factor(dir, f),
    Coordinate(window, axis, coord),
    var new_coord = coord + (d * f).
    
Not_Snapped(a, b) :-
    Moving(a),
    Attracts(a, b, dir),
    Attracts(c, a, dir__prime),
    dir__prime != dir.
    
Snapped(a, b) :-
    Moving(a),
    Attracts(a, b, dir),
    not Not_Snapped(a, b).

Snapped_To_Corner(a, b) :-
    Snapped(a, b),
    Nearest_Side(a, b, dir),
    Axis(dir, ax),
    Opposite_Axis(ax, ax__prime),
    Nearest_Corner(a, b, dir, dir__prime),
    Side(a, dir__prime, side_a),
    Side(b, dir__prime, side_b),
    abs(side_a - side_b) < corner_snapping_threshold().

Final_Coordinate(a, ax, new_coord) :-
   Snapped(a, b),
   Distance(a, b, d),
   Nearest_Side(a, b, dir),
   Axis(dir, ax),
   Coordinate(a, ax, coord),
   Direction_Factor(dir, f),
   var new_coord = coord + d * f.
   
Final_Coordinate(a, ax__prime, new_coord) :-
   Snapped(a, b),
   Snapped_To_Corner(a, b),
   Nearest_Side(a, b, dir),
   Axis(dir, ax),
   Opposite_Axis(ax, ax__prime),
   Nearest_Corner(a, b, dir, dir__prime),
   Coordinate(a, ax__prime, coord),
   Side(a, dir__prime, side_a),
   Side(b, dir__prime, side_b),
   var new_coord = coord + (side_b - side_a).

Final_Coordinate(a, ax__prime, coord) :-
    Snapped(a, b),
    not Snapped_To_Corner(a, b),
    Nearest_Side(a, b, dir),
    Axis(dir, ax),
    Opposite_Axis(ax, ax__prime),
    Coordinate(a, ax__prime, coord).

Not_Final_Coordinate(window, axis, coord) :-
    Coordinate(window, axis, coord),
    Snapped(window, other).

Final_Coordinate(window, axis, coord) :-
    Coordinate(window, axis, coord),
    not Not_Final_Coordinate(window, axis, coord).

Attracts(a, b, dir) :-
    Distance(a, b, d),
    d < snapping_threshold(),
    Closest(a, b),
    Nearest_Side(b, a, dir).

Nearest_Side(a, b, dir) :-
    Instance(a, "Windows"),
    Instance(b, "Windows"),
    Side(a, dir, edge_a),
    Opposite_Direction(dir, dir__prime),
    Side(b, dir__prime, edge_b),
    Distance(a, b, d),
    edge_a - edge_a == d.

Nearest_Side(w, m, dir) :-
    Instance(w, "Windows"),
    Instance(m, "Monitors"),
    Side(w, dir, edge_w),
    Side(m, dir, edge_m),
    Distance(w, m, d),
    edge_w - edge_m == d.
       
Nearest_Side(a, b, dir) :-
    Opposite_Direction(dir, dir__prime),
    Nearest_Side(b, a, dir__prime).
