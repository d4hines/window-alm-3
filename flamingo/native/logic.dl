/////////// Static part of Lib ////////////////
///////////////////////////////////////////////
// Built-in functions
function abs(n: s64): s64 {
   if (n > 0) {
       n
   } else {
       n * -1
   }
}

// Built-in Object ID type
typedef OID = s64

input relation Object(oid: OID, sort: Node, attributes: Map<string, AttributeValue>)
primary key (x) x.oid

// Links together nodes in the sort hiearchy
relation Link(_1: Node, _2: Node)
Link(Actions, Universe).

relation Is_A(_1: OID, _2: Node)
Is_A(obj, sort) :- Object(obj, sort, _).

relation Instance(_1: OID, _2: Node)
Instance(obj, sort) :- Is_A(obj, sort).
Instance(obj, sort1) :- Instance(obj, sort2), Link(sort2, sort1).

input relation InFluent(params: FluentParam, ret: FluentValue)
primary key (x) x.params

output relation OutFluent(params: FluentParam, ret: FluentValue)

//////////// Dynamic Part of Lib ///////////////////
////////////////////////////////////////////////////

// Sort Literals
typedef Axes = X | Y
typedef Directions = DLeft | DRight | DTop | DBottom
typedef Group_Icons = NoIcon | Form | Disband

// Nodes of the hierarchy
typedef Node = Universe
    | Actions
    | Rectangles
    | Monitors
    | Windows
    | Window_Action
    | Open_Window
    | Move
    | Set_Monitor_Bounds
    | Toggle_Grouping

#[rust="serde(untagged)"]
typedef AttributeValue = Attr_Width{width: s64}
    | Attr_Height{height: s64} 
    | Attr_Target{target: OID}
    | Attr_Magnitude_X{magnitude_x: s64}
    | Attr_Magnitude_Y{magnitude_y: s64}
    | Attr_Monitor_X{monitor_x: s64}
    | Attr_Monitor_Y{monitor_y: s64}
    | Attr_Monitor{monitor: OID}

relation Width(oid: OID, value: s64)
Width(oid, x) :- Object(oid, _, attributes),
    Some{Attr_Width{var x}} = map_get(attributes, "width").

relation Height(oid: OID, value: s64)
Height(oid, x) :- Object(oid, _, attributes),
    Some{Attr_Height{var x}} = map_get(attributes, "height").

relation Target(oid: OID, value: OID)
Target(oid, x) :- Object(oid, _, attributes),
    Some{Attr_Target{var x}} = map_get(attributes, "target").

relation Magnitude_X(oid: OID, value: s64)
Magnitude_X(oid, x) :- Object(oid, _, attributes),
    Some{Attr_Magnitude_X{var x}} = map_get(attributes, "magnitude_x").

relation Magnitude_Y(oid: OID, value: s64)
Magnitude_Y(oid, x) :- Object(oid, _, attributes),
    Some{Attr_Magnitude_Y{var x}} = map_get(attributes, "magnitude_y").

relation Monitor_X(oid: OID, value: s64)
Monitor_X(oid, x) :- Object(oid, _, attributes),
    Some{Attr_Monitor_X{var x}} = map_get(attributes, "monitor_x").

relation Monitor_Y(oid: OID, value: s64)
Monitor_Y(oid, x) :- Object(oid, _, attributes),
    Some{Attr_Monitor_Y{var x}} = map_get(attributes, "monitor_y").

relation Monitor(oid: OID, value: OID)
Monitor(oid, x) :- Object(oid, _, attributes),
    Some{Attr_Monitor{var x}} = map_get(attributes, "monitor").

// Encode Hiearchy facts
Link(Window_Action, Actions).
Link(Set_Monitor_Bounds, Actions).
Link(Open_Window, Window_Action).
Link(Move, Window_Action).
Link(Rectangles, Universe).
Link(Monitors, Rectangles).
Link(Windows, Rectangles).
Link(Toggle_Grouping, Window_Action).

// Statics
relation Opposite_Direction(_1: Directions, ret: Directions)
relation Opposite_Axis(_1: Axes, ret: Axes)
relation Axis(_1: Directions, ret: Axes)
relation Direction_Factor(_1: Directions, ret: s64)

/////// Fluents //////////////////
// Basic
typedef FluentParam = Param_Coordinate{coordinate_1: OID, coordinate_2: Axes}
    | Param_Moving{moving_1: OID}
    | Param_Grouped_With{grouped_with_1: OID, grouped_with_2: OID}

typedef FluentValue = Value_Coordinate{coordinate_ret: s64 }
    | Value_Moving{moving_ret: bool}
    | Value_Grouped_With{grouped_with_ret: bool}

// Defined
relation Side(_1: OID, _2: Directions, _3: s64)
relation On_Same_Line(_1: OID, _2: OID, _3: Axes)
relation Overlaps(_1: OID, _2: OID)
relation Attracts(_1: OID, _2: OID, _3: Directions)
relation Not_Snapped(_1: OID, _2: OID)
relation Snapped(_1: OID, _2: OID)
relation Snapped_To_Corner(_1: OID, _2: OID)
relation Distance(_1: OID, _2: OID, _3: s64)
relation Closest(_1: OID, _2: OID)
relation Nearest_Side(_1: OID, _2: OID, _3: Directions)
relation Nearest_Corner(_1: OID, _2: OID, _3: Directions, _4: Directions)
relation In_Snapped_Group(_1: OID)
relation Connected(_1: OID, _2: OID)
relation Not_In_Singleton_Group(_1: OID)
relation Group_Icon(_1: OID, _2: Group_Icons)

relation Final_Coordinate(_1: OID, _2: Axes, _3: s64)
relation Final_Overlaps(_1: OID, _2: OID)
relation Final_Side(_1: OID, _2: Directions, _3: s64)
relation Final_On_Same_Line(_1: OID, _2: OID, _3: Axes)

// Bundle of all the output fluents
#[rust="serde(untagged)"]
typedef Output_Value = Out_Final_Coordinate{final_coordinate: Final_Coordinate}
    | Out_Snapped{snapped: Snapped}
    | Out_Group_Icon{group_icon: Group_Icon}

output relation Output(val: Output_Value)
Output(Out_Final_Coordinate{final_coordinate}) :- Final_Coordinate[final_coordinate].
Output(Out_Snapped{snapped}) :- Snapped[snapped].
Output(Out_Group_Icon{group_icon}) :- Group_Icon[group_icon].

///////////// Axioms ///////////////
function static_Corner_Snapping_Threshold(): s64 {
    30
}
function static_Snapping_Threshold(): s64 {
    30
}

Opposite_Direction(DLeft, DRight).
Opposite_Direction(DTop, DBottom).
Opposite_Direction(a, b) :-
    Opposite_Direction(b, a).
Opposite_Axis(X, Y).
Opposite_Axis(Y, X).
Axis(DLeft, X).
Axis(DTop, Y).
Axis(dir, a) :-
    Axis(dir__prime, a),
    Opposite_Direction(dir, dir__prime).
    
Direction_Factor(DRight, 1).
Direction_Factor(DBottom, 1).
Direction_Factor(DLeft, -1).
Direction_Factor(DTop, -1).

Side(rectangle, DLeft, value) :-
    InFluent(Param_Coordinate{rectangle, X}, Value_Coordinate{value}).

Side(rectangle, DTop, value) :-
    InFluent(Param_Coordinate{rectangle, Y}, Value_Coordinate{value}).

Side(rectangle, DRight, r_value) :-
    Side(rectangle, DLeft, l_value),
    Width(rectangle, w),
    var r_value = l_value + w.

Side(rectangle, DBottom, b_value) :-
    Side(rectangle, DTop, t_value),
    Height(rectangle, h),
    var b_value = t_value + h.

Nearest_Side(a, b, dir) :-
    Instance(a, Windows),
    Instance(b, Windows),
    Side(a, dir, edge_a),
    Opposite_Direction(dir, dir__prime),
    Side(b, dir__prime, edge_b),
    Distance(a, b, d),
    edge_a - edge_b == d,
    Axis(dir, ax),
    Opposite_Axis(ax, ax__prime),
    On_Same_Line(a, b, ax__prime).

Nearest_Side(w, m, dir) :-
    Instance(w, Windows),
    Instance(m, Monitors),
    Side(w, dir, edge_w),
    Side(m, dir, edge_m),
    Distance(w, m, d),
    abs(edge_w - edge_m) == d,
    Axis(dir, ax),
    Opposite_Axis(ax, ax__prime),
    On_Same_Line(w, m, ax__prime).

Nearest_Side(a, b, dir) :-
    Instance(a, Windows),
    Instance(b, Windows),
    Opposite_Direction(dir, dir__prime),
    Nearest_Side(b, a, dir__prime).

Nearest_Side(a, b, dir) :-
    Instance(b, Windows),
    Instance(a, Monitors),
    Nearest_Side(b, a, dir).

Nearest_Corner(a, b, dir, dir__prime) :-
    Nearest_Side(a, b, dir),
    Axis(dir, ax),
    Opposite_Axis(ax, ax__prime),
    Axis(dir__prime, ax__prime),
    Opposite_Direction(dir__prime, dir__prime__prime),
    Side(a, dir__prime, a1),
    Side(b, dir__prime, b1),
    Side(a, dir__prime__prime, a2),
    Side(b, dir__prime__prime, b2),
    abs(a1 - b1)  <  abs(a2 - b2).

Nearest_Corner(a, b, dir, dir__prime) :-
    Nearest_Corner(a, b, dir__prime, dir).

On_Same_Line(a, b, axis) :-
    Side(a, dir, a1),
    Axis(dir, axis),
    Opposite_Direction(dir, dir__prime),
    Side(a, dir__prime, a2),
    Side(b, dir, b1),
    Side(b, dir__prime, b2),
    a != b,
    a1 < b2,
    a2 > b1.

Overlaps(a, b) :-
    On_Same_Line(a, b, X),
    On_Same_Line(a, b, Y).

Distance(a, b, min_d) :-
    Instance(a, Windows),
    Instance(b, Windows),
    not Overlaps(a, b),
    On_Same_Line(a, b, axis),
    Opposite_Axis(axis, axis__prime),
    Axis(dir, axis__prime),
    Side(a, dir, e1),
    Side(b, dir__prime, e2),
    Opposite_Direction(dir, dir__prime),
    var d = abs(e1 - e2),
    var min_d = Aggregate((a, b), group_min(d)).

Distance(a, b, min_d) :-
    Instance(a, Windows),
    Instance(b, Monitors),
    Side(a, dir, e1),
    Side(b, dir, e2),
    var d = abs(e1 - e2),
    var min_d = Aggregate((a, b), group_min(d)).

Distance(a, b, d) :- Distance(b, a, d).

///////////////////// End Stable //////////////////////
//////////////////////////////////////////////////////

///////////////////// Likely Stable ///////////////////
/////////// Open Window
OutFluent(Param_Coordinate{a, X}, Value_Coordinate{0}) :-
    Instance(action, Open_Window),
    Target(action, a).

OutFluent(Param_Coordinate{a, Y}, Value_Coordinate{0}) :-
    Instance(action, Open_Window),
    Target(action, a).

/////////// Set Monitor Bounds ///////////////////
OutFluent(Param_Coordinate{m, X}, Value_Coordinate{x}) :-
    Instance(action, Set_Monitor_Bounds),
    Monitor(action, m),
    Monitor_X(action, x).

OutFluent(Param_Coordinate{m, Y}, Value_Coordinate{y}) :-
    Instance(action, Set_Monitor_Bounds),
    Monitor(action, m),
    Monitor_Y(action, y).

OutFluent(Param_Coordinate{target, X}, Value_Coordinate{new_coord}) :-
    Instance(action, Move),
    Target(action, target),
    Magnitude_X(action, m),
    InFluent(Param_Coordinate{target, X}, Value_Coordinate{coord}),
    var new_coord = coord + m.

OutFluent(Param_Coordinate{target, Y}, Value_Coordinate{new_coord}) :-
    Instance(action, Move),
    Target(action, target),
    Magnitude_Y(action, m),
    InFluent(Param_Coordinate{target, Y}, Value_Coordinate{coord}),
    var new_coord = coord + m.

///////////// This rule is my problem.
OutFluent(Param_Coordinate{window, X}, Value_Coordinate{new_coord}) :-
    Instance(action, Move),
    Target(action, target),
    InFluent(Param_Grouped_With{target, window}, Value_Grouped_With{true}),
    Magnitude_X(action, m),
    InFluent(Param_Coordinate{window, X}, Value_Coordinate{coord}),
    var new_coord = coord + m.
////////////////////////////
OutFluent(Param_Coordinate{window, Y}, Value_Coordinate{new_coord}) :-
    Instance(action, Move),
    Target(action, target),
    InFluent(Param_Grouped_With{target, window}, Value_Grouped_With{true}),
    Magnitude_Y(action, m),
    InFluent(Param_Coordinate{window, Y}, Value_Coordinate{coord}),
    var new_coord = coord + m.

//////////// Moving makes all in group move
OutFluent(Param_Moving{window}, Value_Moving{true}) :-
    Instance(action, Move),
    Target(action, target),
    InFluent(Param_Grouped_With{target, window}, Value_Grouped_With{true}).

//////////////// Moving makes all not in group not move
OutFluent(Param_Moving{other}, Value_Moving{false}) :-
    Instance(action, Move),
    Target(action, window),
    Instance(other, Windows),
    not InFluent(Param_Grouped_With{window, other}, Value_Grouped_With{true}).



//////////////////////// End Likely Stable ///////////////////////////
//////////////////////////////////////////////////////////////////////




























/////////////////////////// Unstable ////////////////////////////////////
Closest(a, b) :-
    Distance(a, b, d),
    var min_d = Aggregate((a, b), group_min(d)).

Not_Snapped(a, b) :-
    InFluent(Param_Moving{a}, Value_Moving{true}),
    Attracts(b, a, dir),
    Attracts(c, a, dir__prime),
    b != c,
    dir__prime != dir.

Snapped(a, b) :-
    InFluent(Param_Moving{a}, Value_Moving{true}),
    Attracts(b, a, dir),
    not Not_Snapped(a, b).


Snapped_To_Corner(a, b) :-
    Snapped(a, b),
    Nearest_Side(a, b, dir),
    Axis(dir, ax),
    Opposite_Axis(ax, ax__prime),
    Nearest_Corner(a, b, dir, dir__prime),
    Side(a, dir__prime, side_a),
    Side(b, dir__prime, side_b),
    abs(side_a - side_b) < static_Corner_Snapping_Threshold(),
    Opposite_Direction(dir__prime, opposite_dir),
    not Nearest_Corner(a, b, opposite_dir, _).

Final_Coordinate(a, ax, new_coord) :-
    InFluent(Param_Grouped_With{b, a}, Value_Grouped_With{true}),
    Snapped(b, c),
    Distance(c, b, d),
    Nearest_Side(b, c, dir),
    Axis(dir, ax),
    InFluent(Param_Coordinate{a, ax}, Value_Coordinate{coord}),
    Direction_Factor(dir, f),
    var new_coord = coord + d * f.

Final_Coordinate(a, ax__prime, new_coord) :-
    InFluent(Param_Grouped_With{b, a}, Value_Grouped_With{true}),
    Snapped(b, c),
    Snapped_To_Corner(b, c),
    Nearest_Side(b, c, dir),
    Axis(dir, ax),
    Opposite_Axis(ax, ax__prime),
    Nearest_Corner(b, c, dir, dir__prime),
    InFluent(Param_Coordinate{a, ax__prime}, Value_Coordinate{coord}),
    Side(b, dir__prime, side_b),
    Side(c, dir__prime, side_c),
    var new_coord = coord + (side_c - side_b).

 Final_Coordinate(a, ax, coord) :-
    InFluent(Param_Coordinate{a, ax}, Value_Coordinate{coord}),
    InFluent(Param_Grouped_With{a, b}, Value_Grouped_With{true}),
    Snapped(b, c),
    not Snapped_To_Corner(b, c),
    Nearest_Side(b, c, dir),
    Axis(dir, ax__prime),
    Opposite_Axis(ax__prime, ax).

In_Snapped_Group(a) :-
    InFluent(Param_Grouped_With{a, b}, Value_Grouped_With{true}),
    Snapped(b, _).

Final_Coordinate(a, axis, coord) :-
   InFluent(Param_Coordinate{a, axis}, Value_Coordinate{coord}),
   not In_Snapped_Group(a).

Attracts(a, b, dir) :-
    Distance(a, b, d),
    d < static_Snapping_Threshold(),
    Closest(b, a),
    Nearest_Side(a, b, dir),
    not InFluent(Param_Grouped_With{a, b}, Value_Grouped_With{true}).

Connected(a, b) :-
    Instance(a, Windows),
    Instance(b, Windows),
    not Final_Overlaps(a, b),
    Final_On_Same_Line(a, b, axis),
    Opposite_Axis(axis, axis__prime),
    Axis(dir, axis__prime),
    Final_Side(a, dir, e1),
    Final_Side(b, dir__prime, e2),
    Opposite_Direction(dir, dir__prime),
    e1 - e2 == 0.

Final_Side(rectangle, DLeft, value) :-
    Final_Coordinate(rectangle, X, value).

Final_Side(rectangle, DTop, value) :-
    Final_Coordinate(rectangle, Y, value).

Final_Side(rectangle, DRight, r_value) :-
    Final_Side(rectangle, DLeft, l_value),
    Width(rectangle, w),
    var r_value = l_value + w.

Final_Side(rectangle, DBottom, b_value) :-
    Final_Side(rectangle, DTop, t_value),
    Height(rectangle, h),
    var b_value = t_value + h.

Final_On_Same_Line(a, b, axis) :-
    Final_Side(a, dir, a1),
    Axis(dir, axis),
    Opposite_Direction(dir, dir__prime),
    Final_Side(a, dir__prime, a2),
    Final_Side(b, dir, b1),
    Final_Side(b, dir__prime, b2),
    a != b,
    a1 < b2,
    a2 > b1.

Final_Overlaps(a, b) :-
    Final_On_Same_Line(a, b, X),
    Final_On_Same_Line(a, b, Y).

Connected(b, a) :- Connected(a, b).
Connected(a, c) :-
    Connected(a, b),
    Connected(b, c).

OutFluent(Param_Grouped_With{a, a}, Value_Grouped_With{true}) :- Instance(a, Windows).

OutFluent(Param_Grouped_With{a, b}, Value_Grouped_With{true}) :-
    Instance(action, Toggle_Grouping),
    Target(action, a),
    Connected(a, b).

OutFluent(Param_Grouped_With{b, a}, Value_Grouped_With{true}) :-
    Instance(action, Toggle_Grouping),
    Target(action, a),
    Connected(a, b).

OutFluent(Param_Coordinate{a,ax}, Value_Coordinate{coord}) :-
    Instance(action, Toggle_Grouping),
    Target(action, a),
    Final_Coordinate(a, ax, coord).
  
Not_In_Singleton_Group(a) :-
    InFluent(Param_Grouped_With{a, b}, Value_Grouped_With{true}),
    a != b.

Group_Icon(a, NoIcon) :-
    Instance(a, Windows),
    not Connected(a, _),
    not Not_In_Singleton_Group(a).

Group_Icon(a, Form) :-
    Connected(a, b),
    not Not_In_Singleton_Group(a).

Group_Icon(a, Disband) :-
    Not_In_Singleton_Group(a).
