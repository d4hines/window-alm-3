// Built-in functions
function abs(n: s64): s64 {
   if (n > 0) n else n * -1
}

// Constant Functions
function corner_snapping_threshold(): s64 {
    20
}

function snapping_threshold(): s64 {
    20
}

// Built-in Object ID type
typedef OID = s64

// Sort Literals
typedef Axes = X | Y
typedef Directions = DLeft | DRight | DTop | DBottom

////////// Sort Hiearchy ///////////////////
// Nodes of the hierarchy
typedef Node = T_Universe
| T_Actions
| T_Window_Action
| T_Open_Window
| T_Drag
| T_Rectangles
| T_Monitors
| T_Windows

// Sorts and attributes
output relation Universe(oid: OID, sort: Node, child: C_Universe)

typedef C_Universe = E_Actions {
    actions: Actions
}
|
E_Rectangles {
    rectangles: Rectangles
}

typedef Actions = Actions {
    child: C_Actions
}

typedef C_Actions = E_Window_Action {
    window_action: Window_Action
}

typedef Window_Action = Window_Action {
    target: OID,
    child: C_Window_Action
}

typedef C_Window_Action = E_Open_Window {
    open_window: Open_Window
}
|
E_Drag {
    drag: Drag
}

typedef Open_Window = Open_Window{
}

typedef Drag = Drag {
   direction: Directions,
   distance: s64
}
// Bottom of 1st branch.

typedef Rectangles = Rectangles {
    width: s64,
    height: s64,
    child: C_rectangles
}

typedef C_rectangles = E_Monitors{
    monitors: Monitors
}
|
E_Windows {
    windows: Windows
}

typedef Monitors = Monitors {
}

typedef Windows = Windows {
}
// Bottom of 2nd branch

// Terminal Sort Constructors
input relation Input_Open_Window(oid: OID, target: OID)
Universe(
        .oid = oid,
        .child = E_Actions {
            .actions = Actions {
                .child = E_Window_Action {
                    .window_action = Window_Action {
                        .target = target,
                        .child = Open_Window {}
                    }
                }
            }
        }
    ) :- Input_Open_Window(oid, target).

input relation Input_Drag(oid: OID, target: OID, distance: s64, direction: Directions)
Universe(
        .oid = oid,
        .child = E_Actions {
            .actions = Actions {
                .child = E_Window_Action {
                    .window_action = Window_Action {
                        .target = target
                        .child = E_Drag {
                            .drag = Drag {
                                .distance = distance,
                                .direction = direction
                            }
                        }
                    }
                }
            }
        }
    ) :- Input_Drag(oid, target, distance, direction).

input relation Input_Monitors(oid: OID, width: s64, height: s64)
Universe(
    .oid = oid,
    .child = E_Rectangles {
        .width = width,
        .height = height,
        .child = Monitors {}
    }
) :- Input_Monitors(oid, width, height).

input relation Input_Windows OID, width: s64, height: s64)
Universe(
    .oid = oid,
    .child = E_Rectangles {
        .width = width,
        .height = height,
        .child = Windows {}
    }
) :- Input_Monitors(oid, width, height).

// Encode Hiearchy facts
output relation Link(_1: Node, _2: Node)
Link(T_Actions, T_Universe).
Link(T_Window_Action, T_Actions).
Link(T_Open_Window, T_Window_Action).
Link(T_Drag, T_Window_Action).
Link(T_Rectangles, T_Universe).
Link(T_Monitors, T_Rectangles).
Link(T_Windows, T_Rectangles).

output relation Is_A(_1: OID, _2: Node)
Is_A(obj, node) :- Universe(obj, node, _).

output relation Instance(_1: OID, _2: Node)
Instance(obj, node) :- Is_A(obj, node).
Instance(obj, node1) :- Instance(obj, node2), Link(node1, node2).

// Statics
output relation Opposite_Direction(_1: Directions, ret: Directions)
output relation Opposite_Axis(_1: Axes, ret: Axes)
output relation Axis(_1: Directions, ret: Axes)
output relation Direction_Factor(_1: Directions, ret: s64)

/////// Fluents //////////////////
// Basic
input relation Input_Coordinate(_1: OID, _2: Axes, ret: s64)
output relation Coordinate(_1: OID, _2: Axes, ret: s64)
Coordinate(x1, x2, x3) :- Input_Coordinate(x1, x2, x3).

// Defined
output relation Side(_1: OID, _2: Directions, _3: s64)
output relation On_Same_Line(_1: OID, _2: OID, _3: Axes)
output relation Overlaps(_1: OID, _2: OID)
output relation Attracts(_1: OID, _2: OID, _3: Directions)
output relation Not_Final_Coordinate(_1: OID, _2: Axes, _3: s64)
output relation Final_Coordinate(_1: OID, _2: Axes, _3: s64)
output relation Not_Snapped(_1: OID, _2: OID)
output relation Snapped(_1: OID, _2: OID)
output relation Snapped_To_Corner(_1: OID, _2: OID)
output relation Moving(_1: OID)
output relation Stationary(_1: OID)
output relation Predistance(_1: OID, _2: OID, _3: s64)
output relation Not_Distance(_1: OID, _2: OID, _3: s64)
output relation Distance(_1: OID, _2: OID, _3: s64)
output relation Not_Closest(_1: OID, _2: OID)
output relation Closest(_1: OID, _2: OID)
output relation Nearest_Side(_1: OID, _2: OID, _3: Directions)
output relation Nearest_Corner(_1: OID, _2: OID, _3: Directions, _4: Directions)

// Causal Law Outputs
output relation Output_Coordinate(_1: OID, _2: Axes, ret: s64)

output relation Output_Moving(_1: OID)
input relation Input_Moving(_1: OID)
Moving(x1) :-Input_Moving(x1).

///////////// Axioms ///////////////
Opposite_Direction(DLeft, DRight).
Opposite_Direction(DTop, DBottom).
Opposite_Direction(a, b) :-
    Opposite_Direction(b, a).
Opposite_Axis(X, Y).
Opposite_Axis(Y, X).
Axis(DLeft, X).
Axis(DTop, Y).
Axis(dir, a) :-
    Axis(dir__prime, a),
    Opposite_Direction(dir, dir__prime).

Direction_Factor(DRight, 1).
Direction_Factor(DBottom, 1).
Direction_Factor(DLeft, -1).
Direction_Factor(DTop, -1).

Side(rectangle, DLeft, value) :-
    Coordinate(rectangle, X, value).
Side(rectangle, DTop, value) :-
    Coordinate(rectangle, X, value).

Side(rectangle, DRight, r_value) :-
    Side(rectangle, DLeft, l_value),
    Universe(.oid = rectangle, .child = E_Rectangles {
        .rectangles = Rectangles {
            .width = w
        }
    }),
    var r_value = l_value + w.

Side(rectangle, DBottom, b_value) :-
    Side(rectangle, DLeft, t_value),
    Universe(.oid = rectangle, .child = E_Rectangles {
        .rectangles = Rectangles {
            .height = h
        }
    }),
    var b_value = t_value + h.

On_Same_Line(a, b, axis) :-
    Side(a, dir, a1),
    Axis(dir, axis),
    Opposite_Direction(dir, dir__prime),
    Side(a, dir__prime, a2),
    Side(b, dir, b1),
    Side(b, dir__prime, b2),
    a != b,
    a1 < b2,
    a2 > b1.

Overlaps(a, b) :-
    On_Same_Line(a, b, X),
    On_Same_Line(a, b, Y).

Predistance(a, b, b) :-
    Instance(a, T_Windows),
    Instance(b, T_Windows),
    On_Same_Line(a, b, axis),
    Axis(dir, axis),
    not Overlaps(a, b),
    Side(a, dir, e1),
    Side(b, dir__prime, e2),
    Opposite_Direction(dir, dir__prime),
    var d = abs(e1 - e2).

Predistance(a, b, d) :-
    Instance(a, T_Windows),
    Instance(b, T_Monitors),
    Side(a, dir, e1),
    Side(b, dir, e2),
    var d = abs(e1 - e2).

Predistance(a, b, d) :-
    Predistance(b, a, d).

Not_Distance(a, b, d) :-
    Predistance(a, b, d),
    Predistance(a, b, d__prime),
    d__prime < d.

Distance(a, b, d) :-
    Predistance(a, b, d),
    not Not_Distance(a, b, d).

Nearest_Corner(a, b, dir, dir__prime) :-
    Nearest_Side(a, b, dir),
    Axis(dir, ax),
    Opposite_Axis(ax, ax__prime),
    Axis(dir__prime, ax__prime),
    Opposite_Direction(dir__prime, dir__prime__prime),
    Side(a, dir__prime, a1),
    Side(a, dir__prime, b1),
    Side(a, dir__prime__prime, a2),
    Side(b, dir__prime__prime, b2),
    abs(a1 - b1)  <  abs(2 - b2).

Nearest_Corner(a, b, dir, dir__prime) :-
    Nearest_Corner(a, b, dir__prime, dir).

Not_Closest(a, b) :- 
    Distance(a, b, d),
    Distance(a, c, d__prime),
    d__prime < d.

Closest(a, b) :-
    Instance(a, T_Windows),
    Instance(b, T_Rectangles),
    not Not_Closest(a, b).

Output_Coordinate(a, X, 0) :-
    Instance(action, T_Open_Window),
    Universe(
        .oid = action,
        .child = E_Actions {
            .actions = Actions {
                .child = E_Window_Action {
                    .window_action = Window_Action {
                        .target = a
                    }
                }
            }
        }
    ).
    
    
Output_Coordinate(a, Y, 0) :-
    Instance(action, T_Open_Window),
    Universe(
        .oid = action,
        .child = E_Actions {
            .actions = Actions {
                .child = E_Window_Action {
                    .window_action = Window_Action {
                        .target = a
                    }
                }
            }
        }
    ).

Nearest_Side(a, b, dir) :-
    Instance(a, T_Windows),
    Instance(b, T_Windows),
    Side(a, dir, edge_a),
    Opposite_Direction(dir, dir__prime),
    Side(b, dir__prime, edge_b),
    Distance(a, b, d),
    edge_a - edge_b == d.

Nearest_Side(w, m, dir) :-
    Instance(w, T_Windows),
    Instance(m, T_Monitors),
    Side(w, dir, edge_w),
    Side(m, dir, edge_m),
    Distance(w, m, d),
    var d__prime = edge_w - edge_m,
    d == d__prime.

Nearest_Side(a, b, dir) :-
    Opposite_Direction(dir, dir__prime),
    Nearest_Side(b, a, dir__prime).

Output_Coordinate(window, axis, new_coord) :-
    Instance(action, T_Drag),
    Universe(
        .oid = action,
        .child = E_Actions {
            .actions = Actions {
                .child = E_Window_Action {
                    .window_action = Window_Action {
                        .target = a,
                        .child = E_Drag {
                            .drag = Drag {
                                .distance = d,
                                .direction = dir
                            }
                        }
                    }
                }
            }
        }
    ),
    Axis(dir, axis),
    Direction_Factor(dir, f),
    Coordinate(window, axis, coord),
    var new_coord = coord + (d * f).
    
Not_Snapped(a, b) :-
    Moving(a),
    Attracts(a, b, dir),
    Attracts(c, a, dir__prime),
    dir__prime != dir.
    
Snapped(a, b) :-
    Moving(a),
    Attracts(a, b, dir),
    not Not_Snapped(a, b).

Snapped_To_Corner(a, b) :-
    Snapped(a, b),
    Nearest_Side(a, b, dir),
    Axis(dir, ax),
    Opposite_Axis(ax, ax__prime),
    Nearest_Corner(a, b, dir, dir__prime),
    Side(a, dir__prime, side_a),
    Side(b, dir__prime, side_b),
    abs(side_a - side_b) < corner_snapping_threshold().

Final_Coordinate(a, ax, new_coord) :-
   Snapped(a, b),
   Distance(a, b, d),
   Nearest_Side(a, b, dir),
   Axis(dir, ax),
   Coordinate(a, ax, coord),
   Direction_Factor(dir, f),
   var new_coord = coord + d * f.
   
Final_Coordinate(a, ax__prime, new_coord) :-
   Snapped(a, b),
   Snapped_To_Corner(a, b),
   Nearest_Side(a, b, dir),
   Axis(dir, ax),
   Opposite_Axis(ax, ax__prime),
   Nearest_Corner(a, b, dir, dir__prime),
   Coordinate(a, ax__prime, coord),
   Side(a, dir__prime, side_a),
   Side(b, dir__prime, side_b),
   var new_coord = coord + (side_b - side_a).

Final_Coordinate(a, ax__prime, coord) :-
    Snapped(a, b),
    not Snapped_To_Corner(a, b),
    Nearest_Side(a, b, dir),
    Axis(dir, ax),
    Opposite_Axis(ax, ax__prime),
    Coordinate(a, ax__prime, coord).

Not_Final_Coordinate(window, axis, coord) :-
    Coordinate(window, axis, coord),
    Snapped(window, other).

Final_Coordinate(window, axis, coord) :-
    Coordinate(window, axis, coord),
    not Not_Final_Coordinate(window, axis, coord).

Attracts(a, b, dir) :-
    Distance(a, b, d),
    d < snapping_threshold(),
    Closest(a, b),
    Nearest_Side(b, a, dir).

Nearest_Side(a, b, dir) :-
    Instance(a, T_Windows),
    Instance(b, T_Windows),
    Side(a, dir, edge_a),
    Opposite_Direction(dir, dir__prime),
    Side(b, dir__prime, edge_b),
    Distance(a, b, d),
    edge_a - edge_a == d.

Nearest_Side(w, m, dir) :-
    Instance(w, T_Windows),
    Instance(m, T_Monitors),
    Side(w, dir, edge_w),
    Side(m, dir, edge_m),
    Distance(w, m, d),
    edge_w - edge_m == d.
       
Nearest_Side(a, b, dir) :-
    Opposite_Direction(dir, dir__prime),
    Nearest_Side(b, a, dir__prime).
