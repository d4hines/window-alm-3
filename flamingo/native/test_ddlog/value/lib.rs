#![allow(
    unused_imports,
    non_snake_case,
    non_camel_case_types,
    non_upper_case_globals,
    unused_parens,
    non_shorthand_field_patterns,
    dead_code,
    overflowing_literals,
    unreachable_patterns,
    unused_variables,
    clippy::unknown_clippy_lints,
    clippy::missing_safety_doc
)]

use std::convert::TryFrom;
use std::ffi;
use std::fmt;
use std::hash::Hash;
use std::result;

use serde::Deserialize;
use serde::Serialize;

use abomonation;

use differential_datalog::ddval::*;
use differential_datalog::decl_ddval_convert;
use differential_datalog::int::*;
use differential_datalog::program::*;
use differential_datalog::record;
use differential_datalog::record::FromRecord;
use differential_datalog::record::IntoRecord;
use differential_datalog::record::RelIdentifier;
use differential_datalog::uint::*;

use fnv::FnvHashMap;
use lazy_static::lazy_static;

use types::*;

/* FlatBuffers bindings generated by `ddlog` */
#[cfg(feature = "flatbuf")]
pub mod flatbuf;

impl TryFrom<&RelIdentifier> for Relations {
    type Error = ();

    fn try_from(rel_id: &RelIdentifier) -> result::Result<Self, Self::Error> {
        match rel_id {
            RelIdentifier::RelName(rname) => Relations::try_from(rname.as_ref()),
            RelIdentifier::RelId(id) => Relations::try_from(*id),
        }
    }
}


pub mod Value
{
    use super::*;
    #[derive(Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
    pub struct __Signedval64 (pub i64);
    impl abomonation::Abomonation for __Signedval64 {}
    impl fmt::Display for __Signedval64 {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for __Signedval64 {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<__Signedval64> for record::Record {
        fn mutate(&self, v: &mut __Signedval64 ) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert!{__Signedval64}
    #[derive(Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
    pub struct __Tuple0__ (pub ());
    impl abomonation::Abomonation for __Tuple0__ {}
    impl fmt::Display for __Tuple0__ {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for __Tuple0__ {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<__Tuple0__> for record::Record {
        fn mutate(&self, v: &mut __Tuple0__ ) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert!{__Tuple0__}
    #[derive(Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
    pub struct __Output_MagicRectangle (pub Output_MagicRectangle);
    impl abomonation::Abomonation for __Output_MagicRectangle {}
    impl fmt::Display for __Output_MagicRectangle {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for __Output_MagicRectangle {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<__Output_MagicRectangle> for record::Record {
        fn mutate(&self, v: &mut __Output_MagicRectangle ) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert!{__Output_MagicRectangle}
    #[derive(Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
    pub struct __Universe (pub Universe);
    impl abomonation::Abomonation for __Universe {}
    impl fmt::Display for __Universe {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for __Universe {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<__Universe> for record::Record {
        fn mutate(&self, v: &mut __Universe ) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert!{__Universe}
}
impl TryFrom<&str> for Relations {
    type Error = ();
    fn try_from(rname: &str) -> result::Result<Self, Self::Error> {
         match rname {
        "Output_MagicRectangle" => Ok(Relations::Output_MagicRectangle),
        "Universe" => Ok(Relations::Universe),
        "__Null" => Ok(Relations::__Null),
             _  => Err(())
         }
    }
}
impl Relations {
    pub fn is_output(&self) -> bool {
        match self {
        Relations::Output_MagicRectangle => true,
            _  => false
        }
    }
}
impl Relations {
    pub fn is_input(&self) -> bool {
        match self {
        Relations::Universe => true,
            _  => false
        }
    }
}
impl TryFrom<RelId> for Relations {
    type Error = ();
    fn try_from(rid: RelId) -> result::Result<Self, Self::Error> {
         match rid {
        0 => Ok(Relations::Output_MagicRectangle),
        1 => Ok(Relations::Universe),
        2 => Ok(Relations::__Null),
             _  => Err(())
         }
    }
}
pub fn relid2name(rid: RelId) -> Option<&'static str> {
   match rid {
        0 => Some(&"Output_MagicRectangle"),
        1 => Some(&"Universe"),
        2 => Some(&"__Null"),
       _  => None
   }
}
pub fn relid2cname(rid: RelId) -> Option<&'static ffi::CStr> {
    RELIDMAPC.get(&rid).map(|c: &'static ffi::CString|c.as_ref())
}
lazy_static! {
    pub static ref RELIDMAP: FnvHashMap<Relations, &'static str> = {
        let mut m = FnvHashMap::default();
        m.insert(Relations::Output_MagicRectangle, "Output_MagicRectangle");
        m.insert(Relations::Universe, "Universe");
        m.insert(Relations::__Null, "__Null");
        m
   };
}
lazy_static! {
    pub static ref RELIDMAPC: FnvHashMap<RelId, ffi::CString> = {
        let mut m = FnvHashMap::default();
        m.insert(0, ffi::CString::new("Output_MagicRectangle").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(1, ffi::CString::new("Universe").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m.insert(2, ffi::CString::new("__Null").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert relation name to C string").unwrap()));
        m
   };
}
lazy_static! {
    pub static ref INPUT_RELIDMAP: FnvHashMap<Relations, &'static str> = {
        let mut m = FnvHashMap::default();
        m.insert(Relations::Universe, "Universe");
        m
    };
}
lazy_static! {
    pub static ref OUTPUT_RELIDMAP: FnvHashMap<Relations, &'static str> = {
        let mut m = FnvHashMap::default();
        m.insert(Relations::Output_MagicRectangle, "Output_MagicRectangle");
        m
    };
}
impl TryFrom<&str> for Indexes {
    type Error = ();
    fn try_from(iname: &str) -> result::Result<Self, Self::Error> {
         match iname {
        "__Null_by_none" => Ok(Indexes::__Null_by_none),
             _  => Err(())
         }
    }
}
impl TryFrom<IdxId> for Indexes {
    type Error = ();
    fn try_from(iid: IdxId) -> result::Result<Self, Self::Error> {
         match iid {
        0 => Ok(Indexes::__Null_by_none),
             _  => Err(())
         }
    }
}
pub fn indexid2name(iid: IdxId) -> Option<&'static str> {
   match iid {
        0 => Some(&"__Null_by_none"),
       _  => None
   }
}
pub fn indexid2cname(iid: IdxId) -> Option<&'static ffi::CStr> {
    IDXIDMAPC.get(&iid).map(|c: &'static ffi::CString|c.as_ref())
}
lazy_static! {
    pub static ref IDXIDMAP: FnvHashMap<Indexes, &'static str> = {
        let mut m = FnvHashMap::default();
        m.insert(Indexes::__Null_by_none, "__Null_by_none");
        m
   };
}
lazy_static! {
    pub static ref IDXIDMAPC: FnvHashMap<IdxId, ffi::CString> = {
        let mut m = FnvHashMap::default();
        m.insert(0, ffi::CString::new("__Null_by_none").unwrap_or_else(|_|ffi::CString::new(r"Cannot convert index name to C string").unwrap()));
        m
   };
}
pub fn relval_from_record(rel: Relations, _rec: &record::Record) -> result::Result<DDValue, String> {
    match rel {
        Relations::Output_MagicRectangle => {
            Ok(Value::__Output_MagicRectangle(<Output_MagicRectangle>::from_record(_rec)?).into_ddvalue())
        },
        Relations::Universe => {
            Ok(Value::__Universe(<Universe>::from_record(_rec)?).into_ddvalue())
        },
        Relations::__Null => {
            Ok(Value::__Tuple0__(<()>::from_record(_rec)?).into_ddvalue())
        }
    }
}
pub fn relkey_from_record(rel: Relations, _rec: &record::Record) -> result::Result<DDValue, String> {
    match rel {
        Relations::Universe => {
            Ok(Value::__Signedval64(<i64>::from_record(_rec)?).into_ddvalue())
        }
        _ => Err(format!("relation {:?} does not have a primary key", rel))
    }
}
pub fn idxkey_from_record(idx: Indexes, _rec: &record::Record) -> result::Result<DDValue, String> {
    match idx {
        Indexes::__Null_by_none => {
            Ok(Value::__Tuple0__(<()>::from_record(_rec)?).into_ddvalue())
        }
    }
}
pub fn indexes2arrid(idx: Indexes) -> ArrId {
    match idx {
        Indexes::__Null_by_none => ( 2, 0),
    }
}
#[derive(Copy,Clone,Debug,PartialEq,Eq,Hash)]
pub enum Relations {
    Output_MagicRectangle = 0,
    Universe = 1,
    __Null = 2
}
#[derive(Copy,Clone,Debug,PartialEq,Eq,Hash)]
pub enum Indexes {
    __Null_by_none = 0
}